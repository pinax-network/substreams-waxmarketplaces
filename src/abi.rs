// Generated by antelope-abi2rs 0.4.1 - eosio::abi/1.1

use serde::{Deserialize, Deserializer, Serialize, de};

type Asset = String;
type Name = String;
type Bool = bool;
type Symbol = String;
type Int64 = i64;
type Uint32 = u32;
type Uint64 = u64;
type Float64 = String;

// ADDED MANUALLY FROM substreams-atomic/src/abi.rs
// https://github.com/pinax-network/substreams-atomic/blob/v0.1.2/src/abi.rs
use serde_json::Value;
fn vec_str_or_u64<'de, D>(deserializer: D) -> Result<Vec<Uint64>, D::Error>
where
    D: Deserializer<'de>,
{
    match Deserialize::deserialize(deserializer)? {
        Value::Array(values) => {
            values
                .into_iter()
                .map(|strnum| match strnum {
                    Value::String(str) => str.parse::<Uint64>().map_err(|_| de::Error::custom(format!("Failed to parse strnum: {}", str))),
                    Value::Number(num) => num.as_u64().ok_or(de::Error::custom(format!("Failed to convert strnum to u64: {}", num))),
                    _ => Err(de::Error::custom("Invalid strnum type")),
                })
                .collect()
        }
        _ => Err(de::Error::custom("Invalid array")),
    }
}

fn str_or_i64<'de, D>(deserializer: D) -> Result<i64, D::Error>
where
    D: Deserializer<'de>,
{
    #[derive(Deserialize)]
    #[serde(untagged)]
    enum StrOrI64<'a> {
        Str(&'a str),
        I64(i64),
    }

    Ok(match StrOrI64::deserialize(deserializer)? {
        StrOrI64::Str(v) => v
            .parse::<i64>()
            .map_err(|_| serde::de::Error::custom("failed to parse i64 number"))?,
        StrOrI64::I64(v) => v,
    })
}

fn str_or_u64<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: Deserializer<'de>,
{
    #[derive(Deserialize)]
    #[serde(untagged)]
    enum StrOrU64<'a> {
        Str(&'a str),
        U64(u64),
    }

    Ok(match StrOrU64::deserialize(deserializer)? {
        StrOrU64::Str(v) => v
            .parse::<u64>()
            .map_err(|_| serde::de::Error::custom("failed to parse u64 number"))?,
        StrOrU64::U64(v) => v,
    })
}

macro_rules! impl_try_from_str {
    ($type:ty) => {
        impl TryFrom<&str> for $type {
            type Error = serde_json::Error;
            #[inline]
            fn try_from(str: &str) -> Result<Self, Self::Error> {
                serde_json::from_str(str)
            }
        }
    };
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct COUNTERRANGE {
    pub counter_name: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub start_id: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub end_id: Uint64,
}
impl_try_from_str!(COUNTERRANGE);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct SYMBOLPAIR {
    pub listing_symbol: Symbol,
    pub settlement_symbol: Symbol,
    pub delphi_pair_name: Name,
    pub invert_delphi_pair: Bool,
}
impl_try_from_str!(SYMBOLPAIR);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct TOKEN {
    pub token_contract: Name,
    pub token_symbol: Symbol,
}
impl_try_from_str!(TOKEN);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Acceptbuyo {
    #[serde(deserialize_with = "str_or_u64")]
    pub buyoffer_id: Uint64,
    pub expected_asset_ids: Vec<Uint64>,
    pub expected_price: Asset,
    pub taker_marketplace: Name,
}
impl_try_from_str!(Acceptbuyo);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Addafeectr {
    #[serde(deserialize_with = "str_or_u64")]
    pub bonusfee_id: Uint64,
    pub counter_name_to_add: Name,
}
impl_try_from_str!(Addafeectr);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Addbonusfee {
    pub fee_recipient: Name,
    pub fee: Float64,
    pub applicable_counter_names: Vec<Name>,
    pub fee_name: String,
}
impl_try_from_str!(Addbonusfee);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Addconftoken {
    pub token_contract: Name,
    pub token_symbol: Symbol,
}
impl_try_from_str!(Addconftoken);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Adddelphi {
    pub delphi_pair_name: Name,
    pub invert_delphi_pair: Bool,
    pub listing_symbol: Symbol,
    pub settlement_symbol: Symbol,
}
impl_try_from_str!(Adddelphi);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Announceauct {
    pub seller: Name,
    // ADDED MANUALLY FROM substreams-atomic/src/abi.rs
    #[serde(deserialize_with = "vec_str_or_u64")]
    pub asset_ids: Vec<Uint64>,
    pub starting_bid: Asset,
    pub duration: Uint32,
    pub maker_marketplace: Name,
}
impl_try_from_str!(Announceauct);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Announcesale {
    pub seller: Name,
    // ADDED MANUALLY FROM substreams-atomic/src/abi.rs
    #[serde(deserialize_with = "vec_str_or_u64")]
    pub asset_ids: Vec<Uint64>,
    pub listing_price: Asset,
    pub settlement_symbol: Symbol,
    pub maker_marketplace: Name,
}
impl_try_from_str!(Announcesale);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Assertauct {
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
    pub asset_ids_to_assert: Vec<Uint64>,
}
impl_try_from_str!(Assertauct);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Assertsale {
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_id: Uint64,
    pub asset_ids_to_assert: Vec<Uint64>,
    pub listing_price_to_assert: Asset,
    pub settlement_symbol_to_assert: Symbol,
}
impl_try_from_str!(Assertsale);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Auctclaimbuy {
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
}
impl_try_from_str!(Auctclaimbuy);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Auctclaimsel {
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
}
impl_try_from_str!(Auctclaimsel);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Auctionbid {
    pub bidder: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
    pub bid: Asset,
    pub taker_marketplace: Name,
}
impl_try_from_str!(Auctionbid);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct AuctionsS {
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
    pub seller: Name,
    pub asset_ids: Vec<Uint64>,
    pub end_time: Uint32,
    pub assets_transferred: Bool,
    pub current_bid: Asset,
    pub current_bidder: Name,
    pub claimed_by_seller: Bool,
    pub claimed_by_buyer: Bool,
    pub maker_marketplace: Name,
    pub taker_marketplace: Name,
    pub collection_name: Name,
    pub collection_fee: Float64,
}
impl_try_from_str!(AuctionsS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct BalancesS {
    pub owner: Name,
    pub quantities: Vec<Asset>,
}
impl_try_from_str!(BalancesS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct BonusfeesS {
    #[serde(deserialize_with = "str_or_u64")]
    pub bonusfee_id: Uint64,
    pub fee_recipient: Name,
    pub fee: Float64,
    pub counter_ranges: Vec<COUNTERRANGE>,
    pub fee_name: String,
}
impl_try_from_str!(BonusfeesS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct BuyoffersS {
    #[serde(deserialize_with = "str_or_u64")]
    pub buyoffer_id: Uint64,
    pub buyer: Name,
    pub recipient: Name,
    pub price: Asset,
    pub asset_ids: Vec<Uint64>,
    pub memo: String,
    pub maker_marketplace: Name,
    pub collection_name: Name,
    pub collection_fee: Float64,
}
impl_try_from_str!(BuyoffersS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Cancelauct {
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
}
impl_try_from_str!(Cancelauct);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Cancelbuyo {
    #[serde(deserialize_with = "str_or_u64")]
    pub buyoffer_id: Uint64,
}
impl_try_from_str!(Cancelbuyo);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Cancelsale {
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_id: Uint64,
}
impl_try_from_str!(Cancelsale);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct ConfigS {
    pub version: String,
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_counter: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_counter: Uint64,
    pub minimum_bid_increase: Float64,
    pub minimum_auction_duration: Uint32,
    pub maximum_auction_duration: Uint32,
    pub auction_reset_duration: Uint32,
    pub supported_tokens: Vec<TOKEN>,
    pub supported_symbol_pairs: Vec<SYMBOLPAIR>,
    pub maker_market_fee: Float64,
    pub taker_market_fee: Float64,
    pub atomicassets_account: Name,
    pub delphioracle_account: Name,
}
impl_try_from_str!(ConfigS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Convcounters {
}
impl_try_from_str!(Convcounters);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct CountersS {
    pub counter_name: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub counter_value: Uint64,
}
impl_try_from_str!(CountersS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Createbuyo {
    pub buyer: Name,
    pub recipient: Name,
    pub price: Asset,
    pub asset_ids: Vec<Uint64>,
    pub memo: String,
    pub maker_marketplace: Name,
}
impl_try_from_str!(Createbuyo);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Declinebuyo {
    #[serde(deserialize_with = "str_or_u64")]
    pub buyoffer_id: Uint64,
    pub decline_memo: String,
}
impl_try_from_str!(Declinebuyo);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Delbonusfee {
    #[serde(deserialize_with = "str_or_u64")]
    pub bonusfee_id: Uint64,
}
impl_try_from_str!(Delbonusfee);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Init {
}
impl_try_from_str!(Init);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Logauctstart {
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
}
impl_try_from_str!(Logauctstart);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Lognewauct {
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
    pub seller: Name,
    pub asset_ids: Vec<Uint64>,
    pub starting_bid: Asset,
    pub duration: Uint32,
    pub end_time: Uint32,
    pub maker_marketplace: Name,
    pub collection_name: Name,
    pub collection_fee: Float64,
}
impl_try_from_str!(Lognewauct);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Lognewbuyo {
    #[serde(deserialize_with = "str_or_u64")]
    pub buyoffer_id: Uint64,
    pub buyer: Name,
    pub recipient: Name,
    pub price: Asset,
    // ADDED MANUALLY FROM substreams-atomic/src/abi.rs
    #[serde(deserialize_with = "vec_str_or_u64")]
    pub asset_ids: Vec<Uint64>,
    pub memo: String,
    pub maker_marketplace: Name,
    pub collection_name: Name,
    pub collection_fee: Float64,
}
impl_try_from_str!(Lognewbuyo);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Lognewsale {
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_id: Uint64,
    pub seller: Name,
    pub asset_ids: Vec<Uint64>,
    pub listing_price: Asset,
    pub settlement_symbol: Symbol,
    pub maker_marketplace: Name,
    pub collection_name: Name,
    pub collection_fee: Float64,
}
impl_try_from_str!(Lognewsale);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Logsalestart {
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_id: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub offer_id: Uint64,
}
impl_try_from_str!(Logsalestart);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct MarketplacesS {
    pub marketplace_name: Name,
    pub creator: Name,
}
impl_try_from_str!(MarketplacesS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Payauctram {
    pub payer: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub auction_id: Uint64,
}
impl_try_from_str!(Payauctram);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Paybuyoram {
    pub payer: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub buyoffer_id: Uint64,
}
impl_try_from_str!(Paybuyoram);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Paysaleram {
    pub payer: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_id: Uint64,
}
impl_try_from_str!(Paysaleram);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Purchasesale {
    pub buyer: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_id: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub intended_delphi_median: Uint64,
    pub taker_marketplace: Name,
}
impl_try_from_str!(Purchasesale);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Regmarket {
    pub creator: Name,
    pub marketplace_name: Name,
}
impl_try_from_str!(Regmarket);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct SalesS {
    #[serde(deserialize_with = "str_or_u64")]
    pub sale_id: Uint64,
    pub seller: Name,
    pub asset_ids: Vec<Uint64>,
    #[serde(deserialize_with = "str_or_i64")]
    pub offer_id: Int64,
    pub listing_price: Asset,
    pub settlement_symbol: Symbol,
    pub maker_marketplace: Name,
    pub collection_name: Name,
    pub collection_fee: Float64,
}
impl_try_from_str!(SalesS);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Setmarketfee {
    pub maker_market_fee: Float64,
    pub taker_market_fee: Float64,
}
impl_try_from_str!(Setmarketfee);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Setminbidinc {
    pub minimum_bid_increase: Float64,
}
impl_try_from_str!(Setminbidinc);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Setversion {
    pub new_version: String,
}
impl_try_from_str!(Setversion);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Stopbonusfee {
    #[serde(deserialize_with = "str_or_u64")]
    pub bonusfee_id: Uint64,
}
impl_try_from_str!(Stopbonusfee);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Withdraw {
    pub owner: Name,
    pub token_to_withdraw: Asset,
}
impl_try_from_str!(Withdraw);

